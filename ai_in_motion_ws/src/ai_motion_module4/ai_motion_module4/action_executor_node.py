"""
Action Executor Node

Implements action execution based on cognitive plans generated by the LLM.
Executes navigation, manipulation, and perception actions for humanoid robots.
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from ai_motion_common_msgs.msg import VoiceCommand, NavigationGoal
from ai_motion_common_msgs.msg import RobotState
from geometry_msgs.msg import Twist, PoseStamped, Point
from sensor_msgs.msg import JointState, LaserScan
from action_msgs.msg import GoalStatus
from rclpy.action import ActionClient, GoalResponse, CancelResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
from nav2_msgs.action import NavigateToPose
from ai_motion_common_msgs.msg import SensorData
from ai_motion_module3.srv import NavigateToPose as NavigateToPoseSrv
from typing import Dict, Any, Optional, List
import math
import time
from enum import Enum


class ActionStatus(Enum):
    IDLE = "idle"
    EXECUTING = "executing"
    SUCCESS = "success"
    FAILED = "failed"
    CANCELLED = "cancelled"


class ActionType(Enum):
    NAVIGATION = "navigation"
    MANIPULATION = "manipulation"
    PERCEPTION = "perception"
    WAIT = "wait"
    REPORT = "report"


class ActionExecutorNode(Node):
    """
    A ROS 2 node that executes actions based on cognitive plans.
    """

    def __init__(self):
        super().__init__('action_executor_node')

        # Initialize action execution state
        self.current_action = None
        self.action_status = ActionStatus.IDLE
        self.action_queue: List[Dict[str, Any]] = []
        self.is_executing = False

        # Action parameters
        self.max_execution_time = 30.0  # seconds
        self.safety_check_interval = 0.5  # seconds
        self.collision_threshold = 0.5  # meters
        self.position_tolerance = 0.2   # meters
        self.orientation_tolerance = 0.1  # radians

        # Create subscribers for robot state and sensor data
        self.robot_state_sub = self.create_subscription(
            RobotState,
            '/robot_state',
            self.robot_state_callback,
            10
        )

        self.joint_state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        self.lidar_sub = self.create_subscription(
            LaserScan,
            '/sensors/lidar/scan',
            self.lidar_callback,
            10
        )

        self.sensor_data_sub = self.create_subscription(
            SensorData,
            '/sensor_data_aggregated',
            self.sensor_data_callback,
            10
        )

        # Create publishers for commands
        self.cmd_vel_pub = self.create_publisher(
            Twist,
            '/cmd_vel',
            10
        )

        self.action_status_pub = self.create_publisher(
            String,
            '/action_executor/status',
            10
        )

        # Create service clients for various actions
        self.nav_to_pose_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Create navigation service client if needed
        self.navigate_to_pose_srv = self.create_client(
            NavigateToPoseSrv,
            '/navigate_to_pose'
        )

        # Initialize state variables
        self.robot_position = Point(x=0.0, y=0.0, z=0.0)
        self.robot_orientation = [0.0, 0.0, 0.0, 1.0]  # x, y, z, w
        self.robot_joint_states = {}
        self.lidar_ranges = None
        self.safety_violated = False

        # Action execution timer
        self.action_timer = self.create_timer(0.1, self.action_execution_loop)

        # Safety check timer
        self.safety_timer = self.create_timer(self.safety_check_interval, self.safety_check)

        # Queue processing timer
        self.queue_timer = self.create_timer(0.5, self.process_action_queue)

        self.get_logger().info('Action Executor Node initialized')

    def robot_state_callback(self, msg: RobotState):
        """
        Callback for robot state updates.
        """
        self.robot_position.x = msg.position.x
        self.robot_position.y = msg.position.y
        self.robot_position.z = msg.position.z
        self.robot_orientation = [
            msg.orientation.x,
            msg.orientation.y,
            msg.orientation.z,
            msg.orientation.w
        ]

    def joint_state_callback(self, msg: JointState):
        """
        Callback for joint state updates.
        """
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.robot_joint_states[name] = msg.position[i]

    def lidar_callback(self, msg: LaserScan):
        """
        Callback for LiDAR data for safety checks.
        """
        self.lidar_ranges = msg.ranges

    def sensor_data_callback(self, msg: SensorData):
        """
        Callback for aggregated sensor data.
        """
        # Process sensor data as needed
        pass

    def execute_action(self, action_data: Dict[str, Any]) -> bool:
        """
        Execute a single action based on the action data.
        """
        action_type = action_data.get('action_type', '').lower()
        parameters = action_data.get('parameters', {})
        description = action_data.get('description', '')

        self.get_logger().info(f'Executing action: {action_type} - {description}')

        self.current_action = action_data
        self.action_status = ActionStatus.EXECUTING

        success = False
        try:
            if action_type == 'navigation':
                success = self.execute_navigation_action(parameters)
            elif action_type == 'manipulation':
                success = self.execute_manipulation_action(parameters)
            elif action_type == 'perception':
                success = self.execute_perception_action(parameters)
            elif action_type == 'wait':
                success = self.execute_wait_action(parameters)
            elif action_type == 'report':
                success = self.execute_report_action(parameters)
            else:
                self.get_logger().error(f'Unknown action type: {action_type}')
                success = False
        except Exception as e:
            self.get_logger().error(f'Error executing action: {e}')
            success = False
        finally:
            self.action_status = ActionStatus.SUCCESS if success else ActionStatus.FAILED
            self.current_action = None

        # Publish action status
        status_msg = String()
        status_msg.data = f"Action {action_type}: {'Success' if success else 'Failed'}"
        self.action_status_pub.publish(status_msg)

        return success

    def execute_navigation_action(self, parameters: Dict[str, Any]) -> bool:
        """
        Execute navigation action to a specified location.
        """
        target_x = parameters.get('destination_x', parameters.get('x', None))
        target_y = parameters.get('destination_y', parameters.get('y', None))
        target_theta = parameters.get('theta', 0.0)

        # If no specific coordinates provided, use named locations
        if target_x is None or target_y is None:
            location = parameters.get('destination', parameters.get('location', ''))
            target_x, target_y = self.get_coordinates_for_location(location)

        if target_x is None or target_y is None:
            self.get_logger().error('No valid destination provided for navigation')
            return False

        self.get_logger().info(f'Navigating to ({target_x}, {target_y}, {target_theta})')

        # Check for navigation server availability
        if not self.nav_to_pose_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('Navigation action server not available')
            return False

        # Create navigation goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = float(target_x)
        goal_msg.pose.pose.position.y = float(target_y)
        goal_msg.pose.pose.position.z = 0.0

        # Convert theta to quaternion
        cos_half = math.cos(target_theta / 2.0)
        sin_half = math.sin(target_theta / 2.0)
        goal_msg.pose.pose.orientation.w = float(cos_half)
        goal_msg.pose.pose.orientation.z = float(sin_half)

        # Send the goal
        future = self.nav_to_pose_client.send_goal_async(
            goal_msg,
            feedback_callback=None
        )

        # Wait for result (with timeout)
        start_time = time.time()
        while (time.time() - start_time) < self.max_execution_time:
            if future.done():
                goal_handle = future.result()
                if goal_handle is not None:
                    result_future = goal_handle.get_result_async()
                    if result_future.done():
                        result = result_future.result()
                        if result.status == GoalStatus.STATUS_SUCCEEDED:
                            self.get_logger().info(f'Successfully navigated to ({target_x}, {target_y})')
                            return True
                        else:
                            self.get_logger().error(f'Navigation failed with status: {result.status}')
                            return False
            time.sleep(0.1)

        # If we reach here, the navigation timed out
        self.get_logger().error('Navigation timed out')
        return False

    def execute_manipulation_action(self, parameters: Dict[str, Any]) -> bool:
        """
        Execute manipulation action like picking up or placing objects.
        """
        action = parameters.get('action', '')
        obj = parameters.get('object', '')
        location = parameters.get('location', '')

        self.get_logger().info(f'Executing manipulation: {action} {obj} at {location}')

        # For simulation, we'll just log the action and return success
        # In a real implementation, this would interface with the robot's manipulator
        if action in ['pick up', 'grab', 'take']:
            self.get_logger().info(f'Picked up {obj}')
        elif action in ['place', 'put down', 'drop']:
            self.get_logger().info(f'Placed {obj} at {location}')
        else:
            self.get_logger().warn(f'Unknown manipulation action: {action}')

        # Simulate action time
        time.sleep(2.0)
        return True

    def execute_perception_action(self, parameters: Dict[str, Any]) -> bool:
        """
        Execute perception action like detecting or identifying objects.
        """
        target = parameters.get('target', '')
        attribute = parameters.get('attribute', '')

        self.get_logger().info(f'Executing perception: looking for {target} with {attribute if attribute else "any"} attributes')

        # For simulation, we'll just log the action and return success
        # In a real implementation, this would interface with perception systems
        self.get_logger().info(f'Perceived {target} successfully')

        # Simulate perception time
        time.sleep(1.0)
        return True

    def execute_wait_action(self, parameters: Dict[str, Any]) -> bool:
        """
        Execute wait action for a specified duration.
        """
        duration = parameters.get('duration', 1.0)
        self.get_logger().info(f'Waiting for {duration} seconds')

        start_time = time.time()
        while (time.time() - start_time) < duration:
            if self.safety_violated:
                self.get_logger().warn('Wait interrupted due to safety violation')
                return False
            time.sleep(0.1)

        return True

    def execute_report_action(self, parameters: Dict[str, Any]) -> bool:
        """
        Execute report action to provide status information.
        """
        info_type = parameters.get('info_type', 'status')
        self.get_logger().info(f'Generating report: {info_type}')

        # Generate a status report
        report = f"Robot status report: Position=({self.robot_position.x:.2f}, {self.robot_position.y:.2f}), "
        report += f"Orientation=({self.robot_orientation[0]:.2f}, {self.robot_orientation[1]:.2f}, {self.robot_orientation[2]:.2f}, {self.robot_orientation[3]:.2f})"

        self.get_logger().info(report)
        return True

    def get_coordinates_for_location(self, location: str) -> tuple:
        """
        Get coordinates for a named location.
        """
        location_coords = {
            "kitchen": (3.0, 2.0),
            "bedroom": (5.0, -1.0),
            "office": (-2.0, 4.0),
            "living room": (0.0, 0.0),
            "front door": (8.0, 0.0),
            "charger": (-5.0, -5.0)
        }

        if location.lower() in location_coords:
            return location_coords[location.lower()]
        else:
            self.get_logger().warn(f'Unknown location: {location}')
            return None, None

    def add_action_to_queue(self, action_data: Dict[str, Any]):
        """
        Add an action to the execution queue.
        """
        self.action_queue.append(action_data)
        self.get_logger().info(f'Added action to queue: {action_data.get("action_type", "unknown")}')

    def process_action_queue(self):
        """
        Process actions in the queue.
        """
        if self.is_executing or not self.action_queue or self.safety_violated:
            return

        self.is_executing = True

        # Process next action in queue
        next_action = self.action_queue.pop(0)
        success = self.execute_action(next_action)

        # Log action completion
        if success:
            self.get_logger().info(f'Successfully executed action: {next_action.get("action_type", "unknown")}')
        else:
            self.get_logger().error(f'Failed to execute action: {next_action.get("action_type", "unknown")}')

        self.is_executing = False

    def action_execution_loop(self):
        """
        Main action execution loop for continuous monitoring.
        """
        # Publish current action status periodically
        status_msg = String()
        status_msg.data = f"Status: {self.action_status.value}"
        if self.current_action:
            status_msg.data += f", Current: {self.current_action.get('action_type', 'unknown')}"
        self.action_status_pub.publish(status_msg)

    def safety_check(self):
        """
        Perform safety checks during action execution.
        """
        if not self.lidar_ranges:
            return

        # Check for obstacles in front of robot
        if self.is_approaching_obstacle():
            self.safety_violated = True
            self.get_logger().warn('Safety violation: obstacle detected too close')

            # Stop robot if it's moving
            self.emergency_stop()
        else:
            self.safety_violated = False

    def is_approaching_obstacle(self) -> bool:
        """
        Check if robot is approaching an obstacle based on LiDAR data.
        """
        if not self.lidar_ranges:
            return False

        # Check forward sector (approximately 60 degrees in front)
        forward_start = int(len(self.lidar_ranges) / 2 - len(self.lidar_ranges) / 12)  # -30 degrees
        forward_end = int(len(self.lidar_ranges) / 2 + len(self.lidar_ranges) / 12)   # +30 degrees

        for i in range(forward_start, forward_end):
            if 0 <= i < len(self.lidar_ranges):
                if self.lidar_ranges[i] <= self.collision_threshold and not math.isinf(self.lidar_ranges[i]):
                    return True

        return False

    def emergency_stop(self):
        """
        Emergency stop for safety.
        """
        cmd = Twist()
        cmd.linear.x = 0.0
        cmd.linear.y = 0.0
        cmd.linear.z = 0.0
        cmd.angular.x = 0.0
        cmd.angular.y = 0.0
        cmd.angular.z = 0.0
        self.cmd_vel_pub.publish(cmd)
        self.get_logger().info('Emergency stop activated')

    def cancel_current_action(self):
        """
        Cancel the current action if possible.
        """
        if self.current_action:
            self.action_status = ActionStatus.CANCELLED
            self.get_logger().info('Current action cancelled')
            return True
        return False


class VLAIntegrationNode(Node):
    """
    Node that integrates voice, language, and action components.
    """

    def __init__(self):
        super().__init__('vla_integration_node')

        # Create subscriber for cognitive plans
        self.plan_sub = self.create_subscription(
            String,
            '/cognitive_plan',
            self.plan_callback,
            10
        )

        # Create action executor
        self.action_executor = ActionExecutorNode()

        self.get_logger().info('VLA Integration Node initialized')

    def plan_callback(self, msg: String):
        """
        Callback for receiving cognitive plans.
        """
        try:
            # Parse the plan from JSON
            plan_data = json.loads(msg.data)
            self.get_logger().info(f'Received plan with {len(plan_data.get("steps", []))} steps')

            # Add each step to the action executor's queue
            for step in plan_data.get('steps', []):
                self.action_executor.add_action_to_queue(step)

        except Exception as e:
            self.get_logger().error(f'Error processing cognitive plan: {e}')


def main(args=None):
    """
    Main function to run the action executor node.
    """
    rclpy.init(args=args)

    action_executor_node = ActionExecutorNode()

    try:
        # Use multithreaded executor to handle callbacks and action execution simultaneously
        executor = MultiThreadedExecutor()
        executor.add_node(action_executor_node)

        try:
            executor.spin()
        except KeyboardInterrupt:
            pass
        finally:
            executor.shutdown()
    except Exception as e:
        action_executor_node.get_logger().error(f'Error in main loop: {e}')
    finally:
        action_executor_node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    import json
    main()